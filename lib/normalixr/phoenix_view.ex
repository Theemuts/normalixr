defmodule Normalixr.PhoenixView
  @moduledoc """
  Support for rendering normalized representations generated by 
  Normalixr.normalize/2. You can render this view by calling 
  render(conn, Normalixr.PhoenixView, "normalized.json", assigns).
  """
  
  @doc """
  Assigns should be a map or keyword list with two fields, :data and
  :fields_to_render. The first is a normalized representation, the second a 
  keyword list which contains a keyword list of options for each of the fields
  you want to render.
  
  The only option which is required is :view, whose value is a the view module
  which contains the appropriate render function for that field. For example,
  if the field :user should be rendered with a render function in 
  MyApp.UserView, you should set the opts as [user: [view: MyApp.UserView]].
  
  By default, the template which is rendered is derived from the field name,
  so the field :user is rendered the "user.json"-template. You can set 
  :template to use another template, for example
  [user: [view: MyApp.UserView, template: "show.json"]].
  
  You can also set the :except and :only fields in the options. Both these
  fields are anonymous functions which takes a single argument, a model in the
  normalized representation, and return either true or false. A model is 
  rendered if and only if only returns true and except returns false. By 
  default, only always returns true and except always returns false.
  
  The final two options which can be set are :raise_if_no_results and
  :dont_render_if_empty. If the first option is set to true and the normalized
  representation contains no models of that type, an Normalixr.EmptyException
  is raised. By default, it is set to false.
  
  If the second option is set to true and the normalized representation 
  contains no models of that type, the field is not rendered. Otherwise, it is
  set to an empty map. By default, it is set to true.
  """

  @spec render(String.t, map, Keyword.t) :: map
  def render("normalized.json", assigns) do
    {normalized_data, fields_to_render} = extract_data_and_opts(assigns)
    
    Enum.map(fields_to_render, fn({field, opts}) ->
      raise_if_no_results = Keyword.get(opts, :allow_no_results, false)
      dont_render_if_empty = Keyword.get(opts, :dont_render_if_empty, true)

      data = normalized_data[field]
      no_data = is_nil data

      if raise_if_no_results and no_data, do: raise "No data"

      if dont_render_if_empty and no_data do
        :ignore
      else
        {field, filter_and_render(data, opts)}    
      end
    end)
    |> Enum.filter(&(&1 != :ignore))
    |> Enum.into(%{})
  end
  
  defp extract_data_and_opts(assigns) when is_list assigns do
    {Keyword.fetch!(assigns, :data), Keyword.fetch!(assigns, :fields_to_render)}
  end
  
  defp extract_data_and_opts(assigns) when is_map assigns do
    {assigns.data, assigns.fields_to_render}
  end

  defp filter_and_render(nil, _), do: %{}

  defp filter_and_render(data, opts) do
    only = Keyword.get(opts, :only, &(true || &1 || &2))
    except = Keyword.get(opts, :except, &(false && &1 && &2))
    view = Keyword.fetch(opts, :view)
    template = Keyword.get(opts, :template, Atom.to_string(field) <> ".json")

    Enum.filter_map(data, &(only.(&1) and not except.(&1)), fn({id, model}) -> 
      rendered_model = view.render(template, [{field, model}, {:normalized_data, normalized_data}])
      {id, rendered_model}
    end)
    |> Enum.into(%{})
  end
end